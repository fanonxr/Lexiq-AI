name: Build and Deploy Container Apps

permissions:
  contents: read

on:
  # Trigger after CI pipeline completes successfully (for push events)
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
    branches:
      - master
      - develop
      - prod
  # For PRs, we still need to check manually since workflow_run doesn't work for PRs
  pull_request:
    branches:
      - master
      - develop
      - prod
      - feature-*/
      - fix-*/
    paths:
      - 'apps/**'
      - 'docker/**'
      - '.github/workflows/deploy-container-apps.yml'
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to deploy (leave empty for all)'
        required: false
        type: choice
        options:
          - all
          - api-core
          - cognitive-orch
          - voice-gateway
          - document-ingestion
          - integration-worker
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: 'Image tag (leave empty to use commit SHA)'
        required: false
        type: string
      skip_checks:
        description: 'Skip test and security checks (use with caution)'
        required: false
        type: boolean
        default: false

env:
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }} # Shared OIDC application ID from shared resources
  REGISTRY_NAME: ${{ secrets.ACR_NAME }} # Shared ACR name (e.g., lexiqaiacrshared)
  RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
  PROJECT_NAME: lexiqai

jobs:
  check-prerequisites:
    name: Check CI Pipeline Status
    runs-on: ubuntu-latest
    # Only run for PRs (workflow_run events don't need this check)
    if: github.event_name == 'pull_request'
    continue-on-error: true  # Don't fail the workflow if CI check fails - let build jobs decide
    permissions:
      contents: read
      actions: read # Required to read workflow run status
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Check CI pipeline workflow status
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const commitSha = context.payload.pull_request.head.sha;
            const branch = context.payload.pull_request.head.ref;
            const maxWaitTime = 600; // 10 minutes - give CI more time
            const checkInterval = 15; // 15 seconds
            let elapsed = 0;
            let relevantRun = null;
            
            // Try to find the workflow run, waiting if it's still running
            while (elapsed < maxWaitTime) {
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'ci.yml',
                per_page: 20
              });
              
              // Find the most recent run for this commit SHA or branch
              relevantRun = runs.workflow_runs.find(run => 
                run.head_sha === commitSha
              ) || runs.workflow_runs.find(run => 
                run.head_branch === branch
              );
              
              if (relevantRun) {
                core.info(`Found CI pipeline run #${relevantRun.run_number} (status: ${relevantRun.status}, conclusion: ${relevantRun.conclusion || 'pending'})`);
                
                // If workflow is still running, wait
                if (relevantRun.status === 'in_progress' || relevantRun.status === 'queued') {
                  core.info(`CI pipeline is still ${relevantRun.status}. Waiting... (${elapsed}s elapsed)`);
                  await new Promise(resolve => setTimeout(resolve, checkInterval * 1000));
                  elapsed += checkInterval;
                  continue;
                }
                
                // Workflow has completed
                break;
              }
              
              // No run found yet, wait a bit
              if (elapsed === 0) {
                core.warning(`No CI pipeline run found yet for commit ${commitSha.substring(0, 7)}. Waiting for it to start...`);
              }
              await new Promise(resolve => setTimeout(resolve, checkInterval * 1000));
              elapsed += checkInterval;
            }
            
            if (!relevantRun) {
              core.warning(`No CI pipeline run found for commit ${commitSha.substring(0, 7)} after ${maxWaitTime}s. Build jobs will proceed but may fail if CI hasn't completed.`);
              return;
            }
            
            if (relevantRun.status !== 'completed') {
              core.warning(`CI pipeline is still ${relevantRun.status} after ${maxWaitTime}s. Build jobs will proceed but may fail if CI hasn't completed.`);
              return;
            }
            
            if (relevantRun.conclusion !== 'success') {
              core.setFailed(`CI pipeline did not pass. Status: ${relevantRun.conclusion}. Check the CI pipeline workflow (run #${relevantRun.run_number}) for details.`);
              return;
            }
            
            // Get all jobs from this workflow run to verify all phases passed
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: relevantRun.id
            });
            
            // Check each job status
            const failedJobs = jobs.jobs.filter(job => 
              job.conclusion !== 'success' && job.conclusion !== 'skipped'
            );
            
            if (failedJobs.length > 0) {
              const failedJobNames = failedJobs.map(job => job.name).join(', ');
              core.setFailed(`Some CI pipeline jobs failed: ${failedJobNames}. All jobs must pass before deployment.`);
            } else {
              core.info(`✓ CI pipeline passed (run #${relevantRun.run_number})`);
              core.info(`  All phases completed: Terraform → Security → Tests`);
            }
  
  verify-ci-passed:
    name: Verify CI Pipeline Passed
    runs-on: ubuntu-latest
    # Only run for workflow_run events to verify CI passed
    if: github.event_name == 'workflow_run'
    steps:
      - name: Verify CI workflow conclusion
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "CI Pipeline did not pass. Conclusion: ${{ github.event.workflow_run.conclusion }}"
            exit 1
          fi
          echo "✓ CI Pipeline passed successfully"

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [check-prerequisites, verify-ci-passed]
    # Run if:
    # - For PRs: check-prerequisites passed OR was skipped (CI check is non-blocking)
    # - For workflow_run: verify-ci-passed succeeded (CI passed)
    # - For manual dispatch: always allow
    if: |
      (github.event_name == 'pull_request' && (needs.check-prerequisites.result == 'success' || needs.check-prerequisites.result == 'skipped' || github.event.inputs.skip_checks == 'true')) ||
      (github.event_name == 'workflow_run' && (needs.verify-ci-passed.result == 'success' || needs.verify-ci-passed.result == 'skipped')) ||
      (github.event_name == 'workflow_dispatch')
    permissions:
      contents: read
      id-token: write # Required for OIDC authentication

    strategy:
      matrix:
        service:
          - name: api-core
            dockerfile: docker/api-core/Dockerfile
            context: .
          - name: cognitive-orch
            dockerfile: docker/cognitive-orch/Dockerfile
            context: .
          - name: voice-gateway
            dockerfile: docker/voice-gateway/Dockerfile
            context: .
          - name: document-ingestion
            dockerfile: docker/document-ingestion/Dockerfile
            context: .
          - name: integration-worker
            dockerfile: docker/integration-worker/Dockerfile
            context: .

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}
          sha: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Azure Login (OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}
          # OIDC authentication - no client-secret needed!

      - name: Authenticate to Azure Container Registry
        run: |
          az acr login --name ${{ env.REGISTRY_NAME }}

      - name: Determine environment and image tags
        id: image_tags
        run: |
          # Determine environment based on branch or input
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            ENV_SUFFIX="${{ github.event.inputs.environment }}"
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
            # For workflow_run events, use the branch from the triggering workflow
            BRANCH="${{ github.event.workflow_run.head_branch }}"
            if [ "$BRANCH" == "prod" ]; then
              ENV_SUFFIX="prod"
            else
              ENV_SUFFIX="dev"
            fi
          elif [ "${{ github.ref }}" == "refs/heads/prod" ]; then
            ENV_SUFFIX="prod"
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            ENV_SUFFIX="dev"
          else
            ENV_SUFFIX="dev"
          fi
          
          # Determine base tag (SHA or custom input)
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            BASE_TAG="${{ github.event.inputs.image_tag }}"
          else
            BASE_TAG="${{ github.sha }}"
          fi
          
          # Create environment-specific tags
          ENV_TAG="${ENV_SUFFIX}-${BASE_TAG}"
          ENV_LATEST="${ENV_SUFFIX}-latest"
          
          echo "environment=${ENV_SUFFIX}" >> $GITHUB_OUTPUT
          echo "base_tag=${BASE_TAG}" >> $GITHUB_OUTPUT
          echo "env_tag=${ENV_TAG}" >> $GITHUB_OUTPUT
          echo "env_latest=${ENV_LATEST}" >> $GITHUB_OUTPUT
          
          echo "Environment: ${ENV_SUFFIX}"
          echo "Base tag: ${BASE_TAG}"
          echo "Environment tag: ${ENV_TAG}"
          echo "Environment latest: ${ENV_LATEST}"

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: |
            ${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.PROJECT_NAME }}/${{ matrix.service.name }}:${{ steps.image_tags.outputs.env_tag }}
            ${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.PROJECT_NAME }}/${{ matrix.service.name }}:${{ steps.image_tags.outputs.env_latest }}
          cache-from: type=registry,ref=${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.PROJECT_NAME }}/${{ matrix.service.name }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.PROJECT_NAME }}/${{ matrix.service.name }}:buildcache,mode=max

      - name: Output image reference
        run: |
          echo "Image: ${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.PROJECT_NAME }}/${{ matrix.service.name }}:${{ steps.image_tags.outputs.env_tag }}"
          echo "Latest: ${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.PROJECT_NAME }}/${{ matrix.service.name }}:${{ steps.image_tags.outputs.env_latest }}"

  deploy:
    name: Deploy to Container Apps
    runs-on: ubuntu-latest
    needs: build-and-push
    # Deploy rules:
    # - For PRs: Only deploy if targeting 'develop' (not prod/staging - requires merge first)
    # - For pushes: Deploy for 'develop' and 'prod' branches
    # - For workflow_run: Deploy for 'develop' and 'prod' branches
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.ref == 'refs/heads/develop' ||
      github.ref == 'refs/heads/prod' ||
      (github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'develop') ||
      (github.event_name == 'workflow_run' && (github.event.workflow_run.head_branch == 'develop' || github.event.workflow_run.head_branch == 'prod'))
    permissions:
      contents: read
      id-token: write # Required for OIDC authentication

    environment:
      # Map branches to environments:
      # - prod → prod
      # - develop → dev
      # For PRs, use base.ref (target branch); for workflow_run, use head_branch; for pushes, use ref
      name: ${{ github.event.inputs.environment || (github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'prod') || (github.event_name == 'workflow_run' && github.event.workflow_run.head_branch == 'prod') || (github.ref == 'refs/heads/prod') && 'prod' || 'dev' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}
          sha: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Azure Login (OIDC)
        uses: azure/login@v1
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}
          # OIDC authentication - no client-secret needed!

      - name: Authenticate to Azure Container Registry
        run: |
          az acr login --name ${{ env.REGISTRY_NAME }}

      - name: Determine environment and image tag
        id: deployment
        run: |
          # Determine environment based on branch or input
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            ENV_SUFFIX="${{ github.event.inputs.environment }}"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, use the target branch (base.ref)
            BRANCH="${{ github.event.pull_request.base.ref }}"
            if [ "$BRANCH" == "prod" ]; then
              ENV_SUFFIX="prod"
            else
              ENV_SUFFIX="dev"
            fi
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
            # For workflow_run events, use the branch from the triggering workflow
            BRANCH="${{ github.event.workflow_run.head_branch }}"
            if [ "$BRANCH" == "prod" ]; then
              ENV_SUFFIX="prod"
            else
              ENV_SUFFIX="dev"
            fi
          elif [ "${{ github.ref }}" == "refs/heads/prod" ]; then
            ENV_SUFFIX="prod"
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            ENV_SUFFIX="dev"
          else
            ENV_SUFFIX="dev"
          fi
          
          # Determine base tag (SHA or custom input)
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            BASE_TAG="${{ github.event.inputs.image_tag }}"
          else
            BASE_TAG="${{ github.sha }}"
          fi
          
          # Create environment-specific tag (matches build-and-push job)
          IMAGE_TAG="${ENV_SUFFIX}-${BASE_TAG}"
          
          echo "environment=${ENV_SUFFIX}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          
          echo "Environment: ${ENV_SUFFIX}"
          echo "Image tag: ${IMAGE_TAG}"

      - name: Deploy Container Apps
        run: |
          ENV_SUFFIX="${{ steps.deployment.outputs.environment }}"
          IMAGE_TAG="${{ steps.deployment.outputs.image_tag }}"
          
          # Services to deploy
          SERVICES="api-core cognitive-orch voice-gateway document-ingestion integration-worker"
          
          if [ -n "${{ github.event.inputs.service }}" ] && [ "${{ github.event.inputs.service }}" != "all" ]; then
            SERVICES="${{ github.event.inputs.service }}"
          fi
          
          for SERVICE in $SERVICES; do
            IMAGE_REF="${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.PROJECT_NAME }}/${SERVICE}:${IMAGE_TAG}"
            echo "Deploying $SERVICE to ${ENV_SUFFIX} environment..."
            echo "Image: ${IMAGE_REF}"
            
            # Update Container App with new revision
            # This creates a new revision automatically
            REVISION_NAME=$(az containerapp update \
              --name "${{ env.PROJECT_NAME }}-${SERVICE}-${ENV_SUFFIX}" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --image "${IMAGE_REF}" \
              --set-env-vars "DEPLOYED_AT=$(date -u +%Y-%m-%dT%H:%M:%SZ),DEPLOYED_BY=${{ github.actor }},DEPLOYED_FROM=${{ github.repository }}" \
              --query "properties.latestRevisionName" -o tsv)
            
            echo "✓ Created revision: $REVISION_NAME for $SERVICE"
          done

      - name: Wait for revisions to be ready
        run: |
          # Map branches to environments:
          # - prod → prod
          # - develop → dev
          if [ -n "${{ github.event.inputs.environment }}" ]; then
            ENV_SUFFIX="${{ github.event.inputs.environment }}"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, use the target branch (base.ref)
            BRANCH="${{ github.event.pull_request.base.ref }}"
            if [ "$BRANCH" == "prod" ]; then
              ENV_SUFFIX="prod"
            else
              ENV_SUFFIX="dev"
            fi
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
            # For workflow_run events, use the branch from the triggering workflow
            BRANCH="${{ github.event.workflow_run.head_branch }}"
            if [ "$BRANCH" == "prod" ]; then
              ENV_SUFFIX="prod"
            else
              ENV_SUFFIX="dev"
            fi
          elif [ "${{ github.ref }}" == "refs/heads/prod" ]; then
            ENV_SUFFIX="prod"
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            ENV_SUFFIX="dev"
          else
            ENV_SUFFIX="dev"
          fi
          SERVICES="api-core cognitive-orch voice-gateway document-ingestion integration-worker"
          
          if [ -n "${{ github.event.inputs.service }}" ] && [ "${{ github.event.inputs.service }}" != "all" ]; then
            SERVICES="${{ github.event.inputs.service }}"
          fi
          
          for SERVICE in $SERVICES; do
            APP_NAME="${{ env.PROJECT_NAME }}-${SERVICE}-${ENV_SUFFIX}"
            echo "Waiting for $SERVICE revision to be ready..."
            
            # Wait for revision to be running
            timeout=300
            elapsed=0
            while [ $elapsed -lt $timeout ]; do
              STATE=$(az containerapp revision list \
                --name "$APP_NAME" \
                --resource-group "${{ env.RESOURCE_GROUP }}" \
                --query "[0].properties.runningState" -o tsv)
              
              if [ "$STATE" == "Running" ]; then
                REVISION=$(az containerapp revision list \
                  --name "$APP_NAME" \
                  --resource-group "${{ env.RESOURCE_GROUP }}" \
                  --query "[0].name" -o tsv)
                echo "✓ $SERVICE revision '$REVISION' is running"
                break
              fi
              
              if [ "$STATE" == "Failed" ]; then
                echo "✗ $SERVICE revision failed to start!"
                echo "Check logs: az containerapp logs show --name $APP_NAME --follow"
                exit 1
              fi
              
              echo "  Waiting... (current state: $STATE)"
              sleep 10
              elapsed=$((elapsed + 10))
            done
            
            if [ $elapsed -ge $timeout ]; then
              echo "✗ Timeout waiting for $SERVICE revision to start"
              exit 1
            fi
          done
